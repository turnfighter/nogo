<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>NoGo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Routing machine (uses OpenStreetMap's OSRM demo server) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>

  <style>
    /* Context menu */
    .ctxmenu {
      position: absolute;
      z-index: 1005;
      display: none;
      min-width: 180px;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.18);
      overflow: hidden;
    }

    .ctxmenu button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      background: none;
      border: 0;
      cursor: pointer;
      font-size: 13px;
    }

    .ctxmenu button:hover {
      background: #f6f7fb;
    }

    /* Measuring visuals */
    .measure-hud {
      position: absolute;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 13px;
      z-index: 1004;
      display: none;
    }

    .measure-marker {
      width: 8px;
      height: 8px;
      background: var(--pink);
      border: 2px solid #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    }

    .leaflet-polyline-measure {
      stroke: #ff4da6;
      stroke-width: 3;
      opacity: 0.95;
    }

    .leaflet-polyline-measure-shadow {
      stroke: #ffd1e8;
      stroke-width: 7;
      opacity: 0.6;
    }

    :root {
      --pink: #ff4da6;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    #map {
      height: 100vh;
      width: 100vw;
    }

    .controls {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1001;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 10px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(6px);
      align-items: center;
    }

    .searchwrap {
      position: relative;
    }

    #destination {
      width: 300px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      font-size: 14px;
      outline: none;
    }

    #go {
      background: var(--pink);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
    }

    #go:active {
      transform: translateY(1px);
    }

    /* Modes */
    .modes {
      display: flex;
      gap: 6px;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 10px;
      padding: 4px;
    }

    .mode {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
      font-size: 13px;
    }

    .mode input {
      display: none;
    }

    .mode.active {
      background: #f7f7f9;
      border-color: rgba(0, 0, 0, 0.15);
    }

    .mode .emoji {
      font-size: 16px;
    }

    /* Autocomplete dropdown */
    #results {
      position: absolute;
      top: 44px;
      left: 0;
      right: 0;
      max-height: 280px;
      overflow: auto;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
      display: none;
      z-index: 1002;
    }

    .result {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
    }

    .result:hover,
    .result.active {
      background: #f7f7f9;
    }

    .pin {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--pink);
      opacity: 0.9;
      flex: 0 0 18px;
    }

    .rmain {
      font-weight: 600;
      font-size: 13px;
      line-height: 1.2;
    }

    .rsub {
      font-size: 12px;
      color: #555;
    }

    .rdist {
      margin-left: auto;
      font-size: 12px;
      color: #111;
      font-variant-numeric: tabular-nums;
    }

    #toast {
      position: absolute;
      left: 50%;
      top: 70px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      display: none;
      font-size: 13px;
      z-index: 1003;
    }

    /* Small screens */
    @media (max-width: 560px) {
      #destination {
        width: 200px;
      }

      .mode span.label {
        display: none;
      }
    }

    .card-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: #0077cc;
      font-weight: 500;
      font-size: 13px;
    }

    .card-btn:hover {
      text-decoration: underline;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
  </style>
</head>

<body>
  <div class="controls">
    <div class="searchwrap">
      <input id="destination" placeholder="Search for a place..." autocomplete="off" />
      <div id="results"></div>
    </div>


    <!-- Transport modes -->
    <div class="modes" id="modes">
      <label class="mode active" data-mode="car" title="Car">
        <input type="radio" name="mode" value="car" checked />
        <span class="emoji">üöó</span><span class="label">Car</span>
      </label>
      <label class="mode" data-mode="walk" title="Walking">
        <input type="radio" name="mode" value="walk" />
        <span class="emoji">üö∂</span><span class="label">Walk</span>
      </label>
      <label class="mode" data-mode="bus" title="Bus">
        <input type="radio" name="mode" value="bus" />
        <span class="emoji">üöå</span><span class="label">Bus</span>
      </label>
      <label class="mode" data-mode="train" title="Train">
        <input type="radio" name="mode" value="train" />
        <span class="emoji">üöÜ</span><span class="label">Train</span>
      </label>
    </div>

    <button id="go">Go</button>
  </div>
  <div id="toast"></div>
  <div id="map"></div>

   <!-- Funny Random Person Popup -->
    <div id="placeCard" style="
    display:none;
    position:absolute;
    top:80px;
    left:16px;
    width:300px;
    background:#fff;
    border-radius:14px;
    box-shadow:0 4px 24px rgba(0,0,0,0.25);
    z-index:1004;
    overflow:hidden;
    font-family:Inter, system-ui;
    animation:fadeIn 0.25s ease-out;
    ">
    <img id="placeCardImg" 
        src="https://source.unsplash.com/600x400/?portrait,person,smile" 
        alt="Profile" 
        style="width:100%; height:180px; object-fit:cover;">
    
    <div style="padding:12px 16px;">
        <h3 id="placeCardName" style="margin:0; font-size:17px; font-weight:600;">
        Alex, 3 km away üòé
        </h3>
        <div id="placeCardDesc" style="font-size:13px; color:#555; margin-top:4px;">
        ‚ÄúJust moved to the neighborhood ‚Äî come say hi üëã‚Äù
        </div>
    </div>

    <div style="
        display:flex; justify-content:center; padding:12px 0; border-top:1px solid #eee;
    ">
        <button id="fakeDirectionsBtn" class="card-btn" 
        style="background:#ff4da6; color:white; padding:8px 18px; border-radius:10px; font-weight:600; border:none; cursor:pointer;">
        Get Directions üòà
        </button>
    </div>

    <button id="placeCardClose" style="
        position:absolute; top:8px; right:10px; border:none; background:rgba(255,255,255,0.9);
        border-radius:50%; width:26px; height:26px; cursor:pointer; font-size:16px; box-shadow:0 1px 4px rgba(0,0,0,0.2);
    ">‚úï</button>
    </div>


  <script>
    /* --- Toast helper --- */
    function showToast(msg, ms = 2000) {
      const t = document.getElementById('toast');
      t.textContent = msg; t.style.display = 'block';
      clearTimeout(t._tid);
      t._tid = setTimeout(() => t.style.display = 'none', ms);
    }

    /* --- Math helpers --- */
    function toRad(d) { return d * Math.PI / 180; }
    function toDeg(r) { return r * 180 / Math.PI; }

    /* Haversine distance (meters) */
    function haversine(a, b) {
      const R = 6371e3;
      const œÜ1 = toRad(a.lat), Œª1 = toRad(a.lng);
      const œÜ2 = toRad(b.lat), Œª2 = toRad(b.lng);
      const dœÜ = œÜ2 - œÜ1, dŒª = Œª2 - Œª1;
      const s = Math.sin(dœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(dŒª / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    function fmtDist(m) { return (m < 1000) ? `${Math.round(m)} m` : `${(m / 1000).toFixed(m < 5000 ? 1 : 0)} km`; }
    function fmtMins(min) {
      if (min < 60) return `${Math.round(min)} min`;
      const h = Math.floor(min / 60), m = Math.round(min % 60);
      return `${h} hr ${m ? m + ' min' : ''}`.trim();
    }

    /* --- Utility: random nearby point --- */
    function destPoint(lat, lon, distanceMeters, bearingRad) {
      const R = 6371e3;
      const œÜ1 = toRad(lat), Œª1 = toRad(lon);
      const Œ¥ = distanceMeters / R, Œ∏ = bearingRad;
      const œÜ2 = Math.asin(Math.sin(œÜ1) * Math.cos(Œ¥) + Math.cos(œÜ1) * Math.sin(Œ¥) * Math.cos(Œ∏));
      const Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏) * Math.sin(Œ¥) * Math.cos(œÜ1), Math.cos(Œ¥) - Math.sin(œÜ1) * Math.sin(œÜ2));
      return { lat: toDeg(œÜ2), lon: ((toDeg(Œª2) + 540) % 360) - 180 };
    }

    /* --- Map setup --- */
    let liveDot = null;        // circleMarker for blue dot
    let accuracyCircle = null; // L.circle for GPS accuracy
    let mapHasCentered = false;

    let map, userMarker, startLatLng, routing;

    const osmStreets = L.tileLayer(
      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { attribution: '&copy; OpenStreetMap contributors' }
    );

    const esriSat1 = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Tiles &copy; Esri ‚Äî Source: Esri, Maxar, Earthstar Geographics, USDA, USGS, AeroGRID, IGN, and the GIS User Community' }
    );
    const esriSat2 = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '' }
    );
    const esriLabels = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { attribution: '&copy; Esri' }
    );
    const satWithLabels = L.layerGroup([esriSat2, esriLabels]);

    const baseMaps = {
      'Streets': osmStreets,
      'Satellite': esriSat1,
      'Satellite + Labels': satWithLabels
    };

    function initMap(lat, lon) {
      map = L.map('map', {
        center: [lat, lon],
        zoom: 14,
        layers: [esriSat1]
      });
      L.control.layers(baseMaps, null, { position: 'topright', collapsed: true }).addTo(map);

    }

    /* === Mode handling === */
    function getSelectedMode() {
      const el = document.querySelector('.modes .mode.active');
      return el ? el.dataset.mode : 'car';
    }
    document.getElementById('modes').addEventListener('click', (e) => {
      const m = e.target.closest('.mode'); if (!m) return;
      document.querySelectorAll('.modes .mode').forEach(x => x.classList.remove('active'));
      m.classList.add('active');
    });

    /* === Transit speed (for bus/train ETA display only) === */
    function estimateTransitMinutes(distanceMeters, mode) {
      const dKm = distanceMeters / 1000;
      const speeds = { bus: 22, train: 80 };
      const wait = { bus: 3 + Math.random() * 7, train: 5 + Math.random() * 15 };
      const move = (dKm / speeds[mode]) * 60;
      return move + wait[mode];
    }

    /* --- Create random nearby lat/lon within radius --- */
    function makeRandomNearbyTarget(center, radiusKm) {
      const dKm = (radiusKm * (0.3 + 0.7 * Math.random()));
      const bearingRad = Math.random() * 2 * Math.PI;
      const p = destPoint(center.lat, center.lng, dKm * 1000, bearingRad);
      return L.latLng(p.lat, p.lon);
    }

    /* ===== NEW: map UI mode -> OSRM profile for /nearest ===== */
    function osrmProfileFor(mode) {
      // OSRM nearest expects 'driving','foot','cycling'
      if (mode === 'walk') return 'foot';
      // treat car/bus/train all as driving geometry to stay on roads
      return 'driving';
    }

    /* ===== NEW: Snap an arbitrary point to nearest road via OSRM /nearest ===== */
    async function snapToRoad(latlng, mode) {
      const prof = osrmProfileFor(mode);
      const url = `https://router.project-osrm.org/nearest/v1/${prof}/${latlng.lng},${latlng.lat}?number=1`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('nearest failed');
      const data = await res.json();
      const wp = data.waypoints && data.waypoints[0];
      if (!wp || !wp.location) throw new Error('no waypoint');
      const [lng, lat] = wp.location;
      return L.latLng(lat, lng);
    }

    /* ===== NEW: Try multiple random points until one snaps to a road ===== */
    async function pickFakeRoutableTarget(center, mode, radiusKm = 5, tries = 6) {
      for (let i = 0; i < tries; i++) {
        const candidate = makeRandomNearbyTarget(center, radiusKm);
        try {
          const snapped = await snapToRoad(candidate, mode);
          // Avoid choosing a point basically at start
          if (haversine(center, snapped) > 200) return snapped;
        } catch (_e) { /* try next */ }
      }
      throw new Error('Could not find routable target');
    }

    /* --- Routing to the FAKE target (snapped), keeps line on map --- */
    function routeToFakeDestination(fakeLatLng, mode) {
      if (routing) { map.removeControl(routing); routing = null; }

      const profile = (mode === 'walk') ? 'foot' : 'car'; // LRM profiles

      routing = L.Routing.control({
        waypoints: [startLatLng, fakeLatLng],
        router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1', profile }),
        lineOptions: {
          styles: [
            { color: '#ffd1e8', opacity: 0.6, weight: 8 },
            { color: '#ff4da6', opacity: 0.95, weight: 5 }
          ]
        },
        addWaypoints: false, draggableWaypoints: false, fitSelectedRoutes: true, show: false
      }).addTo(map);

      routing.on('routesfound', e => {
        const route = e.routes[0];
        const distM = route.summary.totalDistance;
        let etaMin = (mode === 'bus' || mode === 'train')
          ? estimateTransitMinutes(distM, mode)
          : route.summary.totalTime / 60;

        const modeEmoji = { car: 'üöó', walk: 'üö∂', bus: 'üöå', train: 'üöÜ' }[mode];
        const msg = `${modeEmoji} ${mode.toUpperCase()} ‚Ä¢ <b>${fmtDist(distM)}</b> ‚Ä¢ ~<b>${fmtMins(etaMin)}</b>`;

        L.marker(fakeLatLng).addTo(map)
          .bindPopup(`Rerouted! You‚Äôre actually going to a random place üòà<br>${msg}`)
          .openPopup();
      });

      routing.on('routingerror', () => {
        showToast('Routing failed. Picking another nearby road...');
        // try another snapped target quickly
        pickFakeRoutableTarget(startLatLng, mode, 5, 3)
          .then(newTarget => routeToFakeDestination(newTarget, mode))
          .catch(() => showToast('Could not find a road nearby. Try again.'));
      });
    }

    /* --- Geolocation --- */
    (function start() {
      const fallback = { lat: 43.6532, lon: -79.3832 }; // Toronto
      const geoOpts = {
        enableHighAccuracy: true,
        maximumAge: 5000,   // accept a recent fix
        timeout: 12000
      };

      // If geolocation is missing, init map and bail
      if (!navigator.geolocation) {
        initMap(fallback.lat, fallback.lon);
        showToast('Geolocation not supported ‚Äî starting in Toronto.');
        return;
      }

      // Get an initial position quickly to start the map
      navigator.geolocation.getCurrentPosition(
        pos => {
          const { latitude, longitude } = pos.coords;
          initMap(latitude, longitude);
          showToast('Live location found!');
          // Start watching for live updates
          startWatch();
          // Kick off a search if user had text ready
          if (destinationEl.value.trim().length) debounceSearch();
        },
        _err => {
          initMap(fallback.lat, fallback.lon);
          showToast('Location blocked ‚Äî starting in Toronto.');
          // Still try to watch in case permission is granted later
          startWatch();
        },
        geoOpts
      );

      function startWatch() {
        navigator.geolocation.watchPosition(
          pos => {
            const { latitude, longitude, accuracy } = pos.coords;
            const here = L.latLng(latitude, longitude);

            // Set startLatLng on first good fix (used by routing)
            if (!startLatLng) startLatLng = here;

            // Create or move the blue dot
            if (!liveDot) {
              liveDot = L.circleMarker(here, {
                radius: 7,           // inner blue size
                color: '#ffffff',    // white ring
                weight: 2,           // ring thickness
                fillColor: '#1a73e8',// Google blue
                fillOpacity: 1,
                pane: 'markerPane'   // keep above lines
              }).addTo(map);

              // Only center the map the first time we place the dot
              if (!mapHasCentered) {
                map.setView(here, Math.max(map.getZoom(), 15));
                mapHasCentered = true;
              }
            } else {
              liveDot.setLatLng(here);
            }

            // Create or update accuracy bubble
            if (!accuracyCircle) {
              accuracyCircle = L.circle(here, {
                radius: Math.max(accuracy || 0, 10),
                color: '#1a73e8',
                weight: 1,
                opacity: 0.2,
                fillOpacity: 0.08,
                fillColor: '#1a73e8'
              }).addTo(map);
            } else {
              accuracyCircle.setLatLng(here);
              accuracyCircle.setRadius(Math.max(accuracy || 0, 10));
            }

            // Keep the dot above routes/tiles
            liveDot.bringToFront();
          },
          _err => {
            // Don‚Äôt spam‚Äîjust a gentle nudge; map already initialized.
            // console.warn('watchPosition error', _err);
          },
          geoOpts
        );
      }
    })();


    /* ==========================
    Autocomplete place search
    API: Photon/Komoot (OSM)
    ========================== */
    const destinationEl = document.getElementById('destination');
    const resultsEl = document.getElementById('results');
    let currentResults = [];
    let activeIndex = -1;
    let chosenPlace = null;

    function debounce(fn, wait = 250) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); }; }
    function featureName(f) {
      const p = f.properties || {};
      const parts = [p.name, p.street, p.housenumber, p.city || p.town || p.village, p.state, p.country].filter(Boolean);
      return Array.from(new Set(parts)).join(', ');
    }

    async function searchPlaces(q) {
      if (!q) { hideResults(); return; }
      const bias = startLatLng || L.latLng(43.6532, -79.3832);
      const url = new URL('https://photon.komoot.io/api/');
      url.searchParams.set('q', q);
      url.searchParams.set('limit', '8');
      url.searchParams.set('lat', String(bias.lat));
      url.searchParams.set('lon', String(bias.lng));
      url.searchParams.set('lang', 'en');

      try {
        const res = await fetch(url.toString(), { method: 'GET' });
        const data = await res.json();
        const feats = (data.features || []).map(f => {
          const name = featureName(f) || (f.properties && f.properties.osm_value) || 'Unnamed place';
          const coords = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
          const dist = haversine(bias, coords);
          return { name, coords, dist, raw: f };
        });

        feats.sort((a, b) => a.dist - b.dist);
        currentResults = feats; activeIndex = -1; renderResults(feats);
      } catch (e) {
        console.error(e);
        showToast('Search failed. Try again.');
        hideResults();
      }
    }

    function renderResults(items) {
      if (!items.length) { hideResults(); return; }
      resultsEl.innerHTML = items.map((it, i) => `
        <div class="result" data-index="${i}">
        <div class="pin"></div>
        <div>
            <div class="rmain">${escapeHtml(it.name)}</div>
            <div class="rsub">${escapeHtml((it.raw.properties && it.raw.properties.type) || 'POI')}</div>
        </div>
        <div class="rdist">${fmtDist(it.dist)}</div>
        </div>
    `).join('');
      resultsEl.style.display = 'block';
    }
    function hideResults() { resultsEl.style.display = 'none'; resultsEl.innerHTML = ''; currentResults = []; activeIndex = -1; }
    function escapeHtml(s) { return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }


    // Fetches a Wikimedia image by coordinates or name (no API key needed)
    async function fetchWikimediaImageByCoord(lat, lon, titleHint = "") {
      try {
        // Search near the coordinates (5000m radius)
        const url = `https://commons.wikimedia.org/w/api.php?action=query&prop=imageinfo&generator=geosearch&ggscoord=${lat}|${lon}&ggsradius=5000&ggslimit=1&iiprop=url&format=json&origin=*`;
        const res = await fetch(url);
        const data = await res.json();

        if (data?.query?.pages) {
          const page = Object.values(data.query.pages)[0];
          if (page?.imageinfo?.[0]?.url) return page.imageinfo[0].url;
        }

        // If no nearby photo, try name-based search
        if (titleHint) {
          const nameURL = `https://commons.wikimedia.org/w/api.php?action=query&titles=${encodeURIComponent(
            titleHint
          )}&prop=pageimages&pithumbsize=600&format=json&origin=*`;
          const res2 = await fetch(nameURL);
          const data2 = await res2.json();
          const page2 = Object.values(data2.query.pages)[0];
          if (page2?.thumbnail?.source) return page2.thumbnail.source;
        }
      } catch (e) {
        console.warn("No Wikimedia image found:", e);
      }
      return null;
    }


    function chooseIndex(i) {
      if (i < 0 || i >= currentResults.length) return;
      const item = currentResults[i];
      destinationEl.value = item.name;
      chosenPlace = item;
      highlightActive(i);
      hideResults();

      // Random Unsplash image for mock photo
      const randomPhoto = `https://source.unsplash.com/600x400/?${encodeURIComponent(item.name)}`;
      showPlaceCard(item.name, randomPhoto);
    }
    function highlightActive(i) {
      Array.from(resultsEl.children).forEach((el, idx) => { if (idx === i) el.classList.add('active'); else el.classList.remove('active'); });
    }
    function moveActive(delta) {
      if (!currentResults.length) return;
      activeIndex = ((activeIndex + delta) % currentResults.length + currentResults.length) % currentResults.length;
      highlightActive(activeIndex);
    }
    const debounceSearch = debounce(() => searchPlaces(destinationEl.value.trim()), 250);
    destinationEl.addEventListener('input', () => { chosenPlace = null; debounceSearch(); });
    destinationEl.addEventListener('keydown', (e) => {
      if (resultsEl.style.display !== 'block') return;
      if (e.key === 'ArrowDown') { e.preventDefault(); moveActive(1); }
      else if (e.key === 'ArrowUp') { e.preventDefault(); moveActive(-1); }
      else if (e.key === 'Enter') { if (activeIndex >= 0) { e.preventDefault(); chooseIndex(activeIndex); } else hideResults(); }
      else if (e.key === 'Escape') { hideResults(); }
    });
    resultsEl.addEventListener('mousedown', (e) => {
      const card = e.target.closest('.result'); if (!card) return;
      const i = Number(card.getAttribute('data-index')); chooseIndex(i);
    });
    document.addEventListener('click', (e) => { if (!e.target.closest('.searchwrap')) hideResults(); });

    /* --- Go: snap fake target to road, then route --- */
    document.getElementById('go').addEventListener('click', async () => {
      const text = destinationEl.value.trim();
      if (!text) return alert("Type a destination first!");

      const mode = getSelectedMode();

      if (chosenPlace) {
        const d = fmtDist(haversine(startLatLng, chosenPlace.coords));
        showToast(`${mode.toUpperCase()} to ‚Äú${chosenPlace.name}‚Äù is ${d}. Calculating route...`);
      } else {
        showToast(`Searching ‚Äú${text}‚Äù then calculating route (${mode})...`);
      }

      try {
        const fakeSnapped = await pickFakeRoutableTarget(startLatLng, mode, 5, 6);
        routeToFakeDestination(fakeSnapped, mode);
      } catch (e) {
        showToast('Couldn‚Äôt find a nearby road for the fake target. Try again.');
      }
    });

    /* === Left Popup Info Card === */
    // Randomized funny names and captions
    const funnyProfiles = [
    { name: "Alex", quote: "Just moved to the neighborhood ‚Äî come say hi üëã" },
    { name: "Jordan", quote: "Looking for someone to explore nearby spots with üó∫Ô∏è" },
    { name: "Taylor", quote: "You‚Äôll never guess where I am üòè" },
    { name: "Sam", quote: "Says they know a shortcut... don‚Äôt trust them üòà" },
    { name: "Riley", quote: "Apparently only 2 km away. Suspicious ü§î" }
    ];

   function showPlaceCard() {
        const card = document.getElementById("placeCard");
        const img = document.getElementById("placeCardImg");

        const profile = funnyProfiles[Math.floor(Math.random() * funnyProfiles.length)];
        document.getElementById("placeCardName").textContent = `${profile.name}, ${Math.floor(Math.random()*5)+1} km away üòé`;
        document.getElementById("placeCardDesc").textContent = `"${profile.quote}"`;

        const randomNum = Math.floor(Math.random() * 5) + 1;
        img.src = `images/person${randomNum}.jpg`;

        card.style.display = "block";
    }

    // Handle fake ‚ÄúGet Directions‚Äù
    document.getElementById("fakeDirectionsBtn").addEventListener("click", async () => {
    hidePlaceCard();
    const mode = getSelectedMode();
    showToast("Locating new friend üó∫Ô∏è ...");
    try {
        const fakeSnapped = await pickFakeRoutableTarget(startLatLng, mode, 5, 6);
        routeToFakeDestination(fakeSnapped, mode);
    } catch (e) {
        showToast("They disappeared into the void üòÖ");
    }
    });
  </script>
  <!-- Right-click context menu -->
  <div id="ctxmenu" class="ctxmenu"></div>

  <!-- Measure HUD -->
  <div id="measureHUD" class="measure-hud">Distance: 0 m</div>

</body>

</html>
