<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>NoGo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Routing machine (uses OpenStreetMap's OSRM demo server) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>

  <!-- Hot Singles Nearby: HTML + CSS -->
  <style>
    .hsn-card {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 320px;
      max-width: 94vw;
      background: #111;
      color: #fff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 12px 28px rgba(0, 0, 0, .35);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10050;
      display: flex;
      flex-direction: column;
    }

    .hsn-header {
      padding: 12px 16px;
      background: linear-gradient(135deg, #ff4da6, #7b5cff);
      font-weight: 700;
      font-size: 15px
    }

    .hsn-face {
      width: 100%;
      aspect-ratio: 16/10;
      object-fit: cover;
      background: #222;
      display: block
    }

    .hsn-body {
      padding: 12px 12px 14px
    }

    .hsn-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px
    }

    .hsn-name {
      font-weight: 700;
      font-size: 18px
    }

    .hsn-pill {
      font-size: 12px;
      background: #1f1f1f;
      padding: 4px 8px;
      border-radius: 999px;
      opacity: .9
    }

    .hsn-sub {
      margin-top: 6px;
      font-size: 13px;
      color: #cfcfcf;
      line-height: 1.35
    }

    .hsn-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px
    }

    .hsn-btn {
      flex: 1;
      padding: 10px 12px;
      border-radius: 10px;
      border: 0;
      cursor: pointer;
      font-weight: 700
    }

    .hsn-btn.primary {
      background: #ff4da6;
      color: #111
    }

    .hsn-btn.ghost {
      background: #232323;
      color: #fff
    }

    .hsn-powered {
      margin-top: 8px;
      font-size: 11px;
      color: #9a9a9a;
      text-align: center
    }
  </style>

  <div class="hsn-card" id="hsnCard" aria-live="polite">
    <div class="hsn-header">üî• Hot singles in your area</div>
    <img id="hsnFace" class="hsn-face" alt="Nearby match" referrerpolicy="no-referrer">
    <div class="hsn-body">
      <div class="hsn-row">
        <div class="hsn-name" id="hsnName">Loading‚Ä¶</div>
        <div class="hsn-pill" id="hsnAge">‚Äì</div>
        <div class="hsn-pill" id="hsnDistance">‚Äì km away</div>
      </div>
      <div class="hsn-sub" id="hsnTagline">Refreshing your fated match‚Ä¶</div>
      <div class="hsn-actions">
        <button class="hsn-btn ghost" id="hsnNew">New match</button>
        <button class="hsn-btn primary" id="hsnRoute">Get directions</button>
      </div>
      <div class="hsn-powered">Photos from thispersondoesnotexist.com</div>
    </div>
  </div>

  <script>
    (function () {
      const ready = () => window.map && window.L && L.Routing;
      const wait = setInterval(() => { if (!ready()) return; clearInterval(wait); boot(); }, 50);

      function boot() {
        // ---- Config ----
        const ROUTE_RADIUS_MIN_M = 1200, ROUTE_RADIUS_MAX_M = 6000, MAX_ROUTE_TRIES = 6;
        const OSRM_SERVICE = 'https://router.project-osrm.org/route/v1';

        // ---- DOM ----
        const imgEl = document.getElementById('hsnFace');
        const nameEl = document.getElementById('hsnName');
        const ageEl = document.getElementById('hsnAge');
        const distEl = document.getElementById('hsnDistance');
        const tagEl = document.getElementById('hsnTagline');
        const btnNew = document.getElementById('hsnNew');
        const btnGo = document.getElementById('hsnRoute');

        // speed up rendering
        imgEl.loading = 'lazy';
        imgEl.decoding = 'async';

        // ---- Helpers ----
        const firstNames = ['Avery', 'Jordan', 'Riley', 'Taylor', 'Morgan', 'Elliot', 'Rowan', 'Charlie', 'Reese', 'Skyler', 'Alex', 'Quinn', 'Peyton', 'Dakota', 'Casey', 'Remy', 'Jamie', 'Harper', 'Sage', 'Kai'];
        const lastNames = ['Hart', 'Rivera', 'Quinn', 'Stone', 'Bennett', 'Sutton', 'Hayes', 'Reid', 'Brooks', 'Cole', 'Ramos', 'Blake', 'Parker', 'Lane', 'Ellis', 'Greer', 'Monroe', 'Jensen', 'Shaw', 'Wells'];
        const taglines = [
          '‚ÄúWill swipe right for tacos üåÆ.‚Äù',
          '‚ÄúLeft turns only, sorry.‚Äù',
          '‚ÄúScenic route > fastest route.‚Äù',
          '‚ÄúProfessional third-wheeler.‚Äù',
          '‚ÄúHere for wrong directions & right vibes.‚Äù',
          '‚ÄúDog person. Also maps person.‚Äù',
          '‚ÄúLet‚Äôs get lost (locally).‚Äù',
          '‚Äú5‚≠ê date, 2‚≠ê navigator.‚Äù'
        ];
        const rp = a => a[Math.floor(Math.random() * a.length)];
        const rName = () => `${rp(firstNames)} ${rp(lastNames)}`;
        const rAge = () => Math.floor(18 + Math.random() * 21);
        const seed = () => Date.now().toString(36) + Math.random().toString(36).slice(2);

        // ---- Face pipeline (humans only) ----
        async function preload(url) {
          return new Promise((res, rej) => {
            const img = new Image();
            img.referrerPolicy = 'no-referrer';
            img.onload = () => res(url);
            img.onerror = rej;
            img.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(); // cache-bust
          });
        }

        async function getPortraitURL() {
          // 1) randomuser: guaranteed human portraits
          try {
            const r = await fetch('https://randomuser.me/api/?inc=picture&noinfo', { cache: 'no-store' });
            const j = await r.json();
            const url = j?.results?.[0]?.picture?.large || j?.results?.[0]?.picture?.medium;
            if (url) {
              await preload(url);
              return url;
            }
          } catch (e) { /* continue to fallback */ }

          // 2) pravatar: curated human faces (1..70)
          try {
            const n = 1 + Math.floor(Math.random() * 70);
            const url = `https://i.pravatar.cc/512?img=${n}`;
            await preload(url);
            return url;
          } catch (e) { /* continue */ }

          // 3) last resort: thispersondoesnotexist via weserv (some setups block direct calls)
          const url = `https://images.weserv.nl/?url=thispersondoesnotexist.com/image&n=-1&il&af&${seed()}`;
          await preload(url).catch(() => { });
          return url;
        }

        // ---- Map / Router ----
        let userLatLng = null;
        let routingControl = null;

        function ensureRouter() {
          if (routingControl) return routingControl;
          routingControl = L.Routing.control({
            waypoints: [],
            routeWhileDragging: false, addWaypoints: false, show: false, fitSelectedRoutes: true,
            router: new L.Routing.OSRMv1({ serviceUrl: OSRM_SERVICE })
          }).addTo(map);
          return routingControl;
        }

        if (map.locate) {
          map.locate({ setView: false, enableHighAccuracy: true })
            .on('locationfound', e => userLatLng = e.latlng)
            .on('locationerror', () => userLatLng = map.getCenter());
        } else userLatLng = map.getCenter();

        const kmDistance = (a, b) => a && b ? (map.distance(a, b) / 1000) : null;
        function randomNearbyLatLng(origin, minM, maxM) {
          const R = 6371000, d = minM + Math.random() * (maxM - minM), b = Math.random() * 2 * Math.PI;
          const lat1 = origin.lat * Math.PI / 180, lon1 = origin.lng * Math.PI / 180;
          const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d / R) + Math.cos(lat1) * Math.sin(d / R) * Math.cos(b));
          const lon2 = lon1 + Math.atan2(Math.sin(b) * Math.sin(d / R) * Math.cos(lat1), Math.cos(d / R) - Math.sin(lat1) * Math.sin(lat2));
          return L.latLng(lat2 * 180 / Math.PI, lon2 * 180 / Math.PI);
        }

        // ---- Card logic ----
        async function setPortrait() {
          tagEl.textContent = 'Choosing your most photogenic match‚Ä¶';
          try {
            const url = await getPortraitURL();
            imgEl.src = url;
            tagEl.textContent = rp(taglines);
          } catch {
            imgEl.src = `https://i.pravatar.cc/512?u=${seed()}`;
            tagEl.textContent = rp(taglines);
          }
        }

        function generateMatch() {
          const origin = userLatLng || map.getCenter();
          const tempDest = randomNearbyLatLng(origin, ROUTE_RADIUS_MIN_M, ROUTE_RADIUS_MAX_M);

          nameEl.textContent = rName();
          ageEl.textContent = String(rAge());
          tagEl.textContent = rp(taglines);

          const k = kmDistance(origin, tempDest);
          distEl.textContent = (k != null) ? `${k.toFixed(1)} km away` : 'nearby';

          // async portrait (doesn‚Äôt block UI)
          setPortrait();
        }

        async function routeRandom() {
          const origin = userLatLng || map.getCenter();
          try { ensureRouter(); } catch { tagEl.textContent = 'Routing unavailable.'; return; }
          tagEl.textContent = 'Plotting a date spot nearby‚Ä¶';

          let tries = 0, dest = null, ok = false, lastErr = null;
          while (tries < MAX_ROUTE_TRIES && !ok) {
            tries++; dest = randomNearbyLatLng(origin, ROUTE_RADIUS_MIN_M, ROUTE_RADIUS_MAX_M);
            try {
              await new Promise((res, rej) => {
                const t = setTimeout(() => rej(new Error('Timeout')), 6000);
                routingControl.setWaypoints([origin, dest]);
                routingControl.once('routesfound', e => { clearTimeout(t); res(e); });
                routingControl.once('routingerror', e => { clearTimeout(t); rej(e); });
              });
              ok = true;
            } catch (e) { lastErr = e; }
          }
          if (!ok) { console.warn('Routing failed', lastErr); tagEl.textContent = 'Could not find a local spot. Try again!'; return; }

          const r = routingControl._selectedRoute;
          const km = (r && r.summary?.totalDistance) ? r.summary.totalDistance / 1000 : kmDistance(origin, dest);
          distEl.textContent = `${km.toFixed(1)} km away`;
          tagEl.textContent = 'Date spot locked. Good luck üòâ';

          L.marker(dest, { title: 'Mysterious date spot' }).addTo(map)
            .bindPopup('‚ù§Ô∏è Your totally-not-suspicious date spot ‚ù§Ô∏è').openPopup();
        }

        // Events + init
        document.getElementById('hsnNew').addEventListener('click', generateMatch);
        document.getElementById('hsnRoute').addEventListener('click', routeRandom);
        generateMatch();
      }
    })();
  </script>

  <style>
    /* Context menu */
    .ctxmenu {
      position: absolute;
      z-index: 1005;
      display: none;
      min-width: 180px;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.18);
      overflow: hidden;
    }

    .ctxmenu button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      background: none;
      border: 0;
      cursor: pointer;
      font-size: 13px;
    }

    .ctxmenu button:hover {
      background: #f6f7fb;
    }

    /* Measuring visuals */
    .measure-hud {
      position: absolute;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 13px;
      z-index: 1004;
      display: none;
    }

    .measure-marker {
      width: 8px;
      height: 8px;
      background: var(--pink);
      border: 2px solid #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    }

    .leaflet-polyline-measure {
      stroke: #ff4da6;
      stroke-width: 3;
      opacity: 0.95;
    }

    .leaflet-polyline-measure-shadow {
      stroke: #ffd1e8;
      stroke-width: 7;
      opacity: 0.6;
    }

    :root {
      --pink: #ff4da6;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    #map {
      height: 100vh;
      width: 100vw;
    }

    .controls {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1001;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 10px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(6px);
      align-items: center;
    }

    .scenic-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, .15);
      border-radius: 10px;
    }

    .scenic-toggle input {
      display: none;
    }

    .scenic-toggle .knob {
      width: 42px;
      height: 24px;
      background: #eee;
      border-radius: 999px;
      position: relative;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .12);
    }

    .scenic-toggle .knob::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 1px 4px rgba(0, 0, 0, .2);
      transition: all .18s ease;
    }

    .scenic-toggle input:checked+.knob {
      background: #d9f0ff;
    }

    .scenic-toggle input:checked+.knob::after {
      transform: translateX(18px);
      background: #1a73e8;
    }

    .scenic-toggle .txt {
      font-size: 13px;
      font-weight: 600;
    }

    .searchwrap {
      position: relative;
    }

    #destination {
      width: 300px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      font-size: 14px;
      outline: none;
    }

    #go {
      background: var(--pink);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
    }

    #go:active {
      transform: translateY(1px);
    }

    /* Modes */
    .modes {
      display: flex;
      gap: 6px;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 10px;
      padding: 4px;
    }

    .mode {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
      font-size: 13px;
    }

    .mode input {
      display: none;
    }

    .mode.active {
      background: #f7f7f9;
      border-color: rgba(0, 0, 0, 0.15);
    }

    .mode .emoji {
      font-size: 16px;
    }

    /* Autocomplete dropdown */
    #results {
      position: absolute;
      top: 44px;
      left: 0;
      right: 0;
      max-height: 280px;
      overflow: auto;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
      display: none;
      z-index: 1002;
    }

    .result {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
    }

    .result:hover,
    .result.active {
      background: #f7f7f9;
    }

    .pin {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--pink);
      opacity: 0.9;
      flex: 0 0 18px;
    }

    .rmain {
      font-weight: 600;
      font-size: 13px;
      line-height: 1.2;
    }

    .rsub {
      font-size: 12px;
      color: #555;
    }

    .rdist {
      margin-left: auto;
      font-size: 12px;
      color: #111;
      font-variant-numeric: tabular-nums;
    }

    #toast {
      position: absolute;
      left: 50%;
      top: 70px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      display: none;
      font-size: 13px;
      z-index: 1003;
    }

    /* Small screens */
    @media (max-width: 560px) {
      #destination {
        width: 200px;
      }

      .mode span.label {
        display: none;
      }
    }

    .card-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: #0077cc;
      font-weight: 500;
      font-size: 13px;
    }

    .card-btn:hover {
      text-decoration: underline;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
  </style>
</head>

<body>
  <div class="controls">
    <div class="searchwrap">
      <input id="destination" placeholder="Search for a place..." autocomplete="off" />
      <div id="results"></div>
    </div>
    <!-- Scenic toggle -->
    <label class="scenic-toggle" title="Take the long way">
      <input type="checkbox" id="scenicToggle" />
      <span class="knob"></span>
      <span class="txt">Scenic route üó∫Ô∏è</span>
    </label>



    <!-- Transport modes -->
    <div class="modes" id="modes">
      <label class="mode active" data-mode="car" title="Car">
        <input type="radio" name="mode" value="car" checked />
        <span class="emoji">üöó</span><span class="label">Car</span>
      </label>
      <label class="mode" data-mode="walk" title="Walking">
        <input type="radio" name="mode" value="walk" />
        <span class="emoji">üö∂</span><span class="label">Walk</span>
      </label>
      <label class="mode" data-mode="bus" title="Bus">
        <input type="radio" name="mode" value="bus" />
        <span class="emoji">üöå</span><span class="label">Bus</span>
      </label>
      <label class="mode" data-mode="train" title="Train">
        <input type="radio" name="mode" value="train" />
        <span class="emoji">üöÜ</span><span class="label">Train</span>
      </label>
    </div>

    <button id="go">Go</button>
  </div>
  <div id="toast"></div>
  <div id="map"></div>

  <!-- Place Info Panel -->
  <!-- Left-side Place Info Popup -->
  <div id="placeCard" style="
    display:none;
    position:absolute;
    top:80px;
    left:16px;
    width:320px;
    background:#fff;
    border-radius:14px;
    box-shadow:0 4px 24px rgba(0,0,0,0.25);
    z-index:1004;
    overflow:hidden;
    font-family:Inter, system-ui;
    animation:fadeIn 0.25s ease-out;
    ">
    <img id="placeCardImg" src="" alt="Place image" style="width:100%; height:160px; object-fit:cover;">

    <div style="padding:12px 16px;">
      <h3 id="placeCardName" style="margin:0; font-size:17px; font-weight:600;">McDonald's</h3>
      <div style="font-size:13px; color:#666; margin-top:4px;">
        ‚≠ê 3.5 (1,390) ‚Ä¢ $10‚Äì20 ‚Ä¢ Fast food restaurant
      </div>
    </div>

    <div
      style="display:flex; justify-content:space-around; padding:8px 0; border-top:1px solid #eee; border-bottom:1px solid #eee;">
      <button class="card-btn">Directions</button>
      <button class="card-btn">Save</button>
      <button class="card-btn">Nearby</button>
      <button class="card-btn">Share</button>
    </div>

    <div
      style="display:flex; justify-content:space-around; font-size:13px; padding:8px 0; color:#0077cc; border-bottom:1px solid #eee;">
      <div>Overview</div>
      <div>Menu</div>
      <div>Reviews</div>
      <div>About</div>
    </div>

    <div style="padding:10px 16px 16px 16px; font-size:13px; color:#444;">
      Classic, long-running fast food chain known for burgers and fries üçü.
    </div>

    <button id="placeCardClose" style="
        position:absolute; top:8px; right:10px; border:none; background:rgba(255,255,255,0.9);
        border-radius:50%; width:26px; height:26px; cursor:pointer; font-size:16px; box-shadow:0 1px 4px rgba(0,0,0,0.2);
    ">‚úï</button>
  </div>


  <script>
    /* --- Toast helper --- */
    function showToast(msg, ms = 2000) {
      const t = document.getElementById('toast');
      t.textContent = msg; t.style.display = 'block';
      clearTimeout(t._tid);
      t._tid = setTimeout(() => t.style.display = 'none', ms);
    }

    /* --- Math helpers --- */
    function toRad(d) { return d * Math.PI / 180; }
    function toDeg(r) { return r * 180 / Math.PI; }

    /* Haversine distance (meters) */
    function haversine(a, b) {
      const R = 6371e3;
      const œÜ1 = toRad(a.lat), Œª1 = toRad(a.lng);
      const œÜ2 = toRad(b.lat), Œª2 = toRad(b.lng);
      const dœÜ = œÜ2 - œÜ1, dŒª = Œª2 - Œª1;
      const s = Math.sin(dœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(dŒª / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    function fmtDist(m) { return (m < 1000) ? `${Math.round(m)} m` : `${(m / 1000).toFixed(m < 5000 ? 1 : 0)} km`; }
    function fmtMins(min) {
      if (min < 60) return `${Math.round(min)} min`;
      const h = Math.floor(min / 60), m = Math.round(min % 60);
      return `${h} hr ${m ? m + ' min' : ''}`.trim();
    }

    /* --- Utility: random nearby point --- */
    function destPoint(lat, lon, distanceMeters, bearingRad) {
      const R = 6371e3;
      const œÜ1 = toRad(lat), Œª1 = toRad(lon);
      const Œ¥ = distanceMeters / R, Œ∏ = bearingRad;
      const œÜ2 = Math.asin(Math.sin(œÜ1) * Math.cos(Œ¥) + Math.cos(œÜ1) * Math.sin(Œ¥) * Math.cos(Œ∏));
      const Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏) * Math.sin(Œ¥) * Math.cos(œÜ1), Math.cos(Œ¥) - Math.sin(œÜ1) * Math.sin(œÜ2));
      return { lat: toDeg(œÜ2), lon: ((toDeg(Œª2) + 540) % 360) - 180 };
    }

    /* --- Map setup --- */
    let liveDot = null;        // circleMarker for blue dot
    let accuracyCircle = null; // L.circle for GPS accuracy
    let mapHasCentered = false;

    let map, userMarker, startLatLng, routing;

    const osmStreets = L.tileLayer(
      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { attribution: '&copy; OpenStreetMap contributors' }
    );

    const esriSat1 = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Tiles &copy; Esri ‚Äî Source: Esri, Maxar, Earthstar Geographics, USDA, USGS, AeroGRID, IGN, and the GIS User Community' }
    );
    const esriSat2 = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '' }
    );
    const esriLabels = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { attribution: '&copy; Esri' }
    );
    const satWithLabels = L.layerGroup([esriSat2, esriLabels]);

    const baseMaps = {
      'Streets': osmStreets,
      'Satellite': esriSat1,
      'Satellite + Labels': satWithLabels
    };

    function initMap(lat, lon) {
      map = L.map('map', {
        center: [lat, lon],
        zoom: 14,
        layers: [esriSat1]
      });
      L.control.layers(baseMaps, null, { position: 'topright', collapsed: true }).addTo(map);

    }

    /* === Mode handling === */
    function getSelectedMode() {
      const el = document.querySelector('.modes .mode.active');
      return el ? el.dataset.mode : 'car';
    }
    document.getElementById('modes').addEventListener('click', (e) => {
      const m = e.target.closest('.mode'); if (!m) return;
      document.querySelectorAll('.modes .mode').forEach(x => x.classList.remove('active'));
      m.classList.add('active');
    });

    /* === Transit speed (for bus/train ETA display only) === */
    function estimateTransitMinutes(distanceMeters, mode) {
      const dKm = distanceMeters / 1000;
      const speeds = { bus: 22, train: 80 };
      const wait = { bus: 3 + Math.random() * 7, train: 5 + Math.random() * 15 };
      const move = (dKm / speeds[mode]) * 60;
      return move + wait[mode];
    }

    /* --- Create random nearby lat/lon within radius --- */
    function makeRandomNearbyTarget(center, radiusKm) {
      const dKm = (radiusKm * (0.3 + 0.7 * Math.random()));
      const bearingRad = Math.random() * 2 * Math.PI;
      const p = destPoint(center.lat, center.lng, dKm * 1000, bearingRad);
      return L.latLng(p.lat, p.lon);
    }

    /* ===== NEW: map UI mode -> OSRM profile for /nearest ===== */
    function osrmProfileFor(mode) {
      // OSRM nearest expects 'driving','foot','cycling'
      if (mode === 'walk') return 'foot';
      // treat car/bus/train all as driving geometry to stay on roads
      return 'driving';
    }

    /* ===== NEW: Snap an arbitrary point to nearest road via OSRM /nearest ===== */
    async function snapToRoad(latlng, mode) {
      const prof = osrmProfileFor(mode);
      const url = `https://router.project-osrm.org/nearest/v1/${prof}/${latlng.lng},${latlng.lat}?number=1`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('nearest failed');
      const data = await res.json();
      const wp = data.waypoints && data.waypoints[0];
      if (!wp || !wp.location) throw new Error('no waypoint');
      const [lng, lat] = wp.location;
      return L.latLng(lat, lng);
    }

    /* ===== NEW: Try multiple random points until one snaps to a road ===== */
    async function pickFakeRoutableTarget(center, mode, radiusKm = 5, tries = 6) {
      for (let i = 0; i < tries; i++) {
        const candidate = makeRandomNearbyTarget(center, radiusKm);
        try {
          const snapped = await snapToRoad(candidate, mode);
          // Avoid choosing a point basically at start
          if (haversine(center, snapped) > 200) return snapped;
        } catch (_e) { /* try next */ }
      }
      throw new Error('Could not find routable target');
    }

    /* --- Routing to the FAKE target (snapped), keeps line on map --- */
    function routeToFakeDestination(fakeLatLng, mode) {
      if (routing) { map.removeControl(routing); routing = null; }

      const profile = (mode === 'walk') ? 'foot' : 'car'; // LRM profiles

      routing = L.Routing.control({
        waypoints: [startLatLng, fakeLatLng],
        router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1', profile }),
        addWaypoints: false,
        draggableWaypoints: false,
        fitSelectedRoutes: false,
        show: false,
        // Make LRM's own route line invisible; we'll draw our own animated one.
        routeLine: (route) => L.Routing.line(route, {
          addWaypoints: false,
          styles: [{ color: '#000', opacity: 0, weight: 0.0001 }]
        })
      }).addTo(map);


      routing.on('routesfound', e => {
        const route = e.routes[0];
        const coords = route.coordinates.map(c => [c.lat, c.lng]);

        // üö® Draw the animated ‚Äúsnake‚Äù route
        drawSnakingRoute(coords, {
          color: '#ff4da6',
          shadowColor: '#ffd1e8',
          durationMs: Math.min(3500, Math.max(1200, route.summary.totalDistance / 2)),
          // distance-based timing: ~2ms per meter, clamped
        });

        const distM = route.summary.totalDistance;
        let etaMin = (mode === 'bus' || mode === 'train')
          ? estimateTransitMinutes(distM, mode)
          : route.summary.totalTime / 60;

        const modeEmoji = { car: 'üöó', walk: 'üö∂', bus: 'üöå', train: 'üöÜ' }[mode];
        const msg = `${modeEmoji} ${mode.toUpperCase()} ‚Ä¢ <b>${fmtDist(distM)}</b> ‚Ä¢ ~<b>${fmtMins(etaMin)}</b>`;

        L.marker(fakeLatLng).addTo(map)
          .bindPopup(`Rerouted! You‚Äôre actually going to a random place üòà<br>${msg}`)
          .openPopup();
      });


      routing.on('routingerror', () => {
        showToast('Routing failed. Picking another nearby road...');
        // try another snapped target quickly
        pickFakeRoutableTarget(startLatLng, mode, 5, 3)
          .then(newTarget => routeToFakeDestination(newTarget, mode))
          .catch(() => showToast('Could not find a road nearby. Try again.'));
      });
    }

    /* --- Geolocation --- */
    (function start() {
      const fallback = { lat: 43.6532, lon: -79.3832 }; // Toronto
      const geoOpts = {
        enableHighAccuracy: true,
        maximumAge: 5000,   // accept a recent fix
        timeout: 12000
      };

      // If geolocation is missing, init map and bail
      if (!navigator.geolocation) {
        initMap(fallback.lat, fallback.lon);
        showToast('Geolocation not supported ‚Äî starting in Toronto.');
        return;
      }

      // Get an initial position quickly to start the map
      navigator.geolocation.getCurrentPosition(
        pos => {
          const { latitude, longitude } = pos.coords;
          initMap(latitude, longitude);
          showToast('Live location found!');
          // Start watching for live updates
          startWatch();
          // Kick off a search if user had text ready
          if (destinationEl.value.trim().length) debounceSearch();
        },
        _err => {
          initMap(fallback.lat, fallback.lon);
          showToast('Location blocked ‚Äî starting in Toronto.');
          // Still try to watch in case permission is granted later
          startWatch();
        },
        geoOpts
      );

      function startWatch() {
        navigator.geolocation.watchPosition(
          pos => {
            const { latitude, longitude, accuracy } = pos.coords;
            const here = L.latLng(latitude, longitude);

            // Set startLatLng on first good fix (used by routing)
            if (!startLatLng) startLatLng = here;

            // Create or move the blue dot
            if (!liveDot) {
              liveDot = L.circleMarker(here, {
                radius: 7,           // inner blue size
                color: '#ffffff',    // white ring
                weight: 2,           // ring thickness
                fillColor: '#1a73e8',// Google blue
                fillOpacity: 1,
                pane: 'markerPane'   // keep above lines
              }).addTo(map);

              // Only center the map the first time we place the dot
              if (!mapHasCentered) {
                map.setView(here, Math.max(map.getZoom(), 15));
                mapHasCentered = true;
              }
            } else {
              liveDot.setLatLng(here);
            }

            // Create or update accuracy bubble
            if (!accuracyCircle) {
              accuracyCircle = L.circle(here, {
                radius: Math.max(accuracy || 0, 10),
                color: '#1a73e8',
                weight: 1,
                opacity: 0.2,
                fillOpacity: 0.08,
                fillColor: '#1a73e8'
              }).addTo(map);
            } else {
              accuracyCircle.setLatLng(here);
              accuracyCircle.setRadius(Math.max(accuracy || 0, 10));
            }

            // Keep the dot above routes/tiles
            liveDot.bringToFront();
          },
          _err => {
            // Don‚Äôt spam‚Äîjust a gentle nudge; map already initialized.
            // console.warn('watchPosition error', _err);
          },
          geoOpts
        );
      }
    })();


    /* ==========================
    Autocomplete place search
    API: Photon/Komoot (OSM)
    ========================== */
    const destinationEl = document.getElementById('destination');
    const resultsEl = document.getElementById('results');
    let currentResults = [];
    let activeIndex = -1;
    let chosenPlace = null;

    function debounce(fn, wait = 250) { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); }; }
    function featureName(f) {
      const p = f.properties || {};
      const parts = [p.name, p.street, p.housenumber, p.city || p.town || p.village, p.state, p.country].filter(Boolean);
      return Array.from(new Set(parts)).join(', ');
    }

    async function searchPlaces(q) {
      if (!q) { hideResults(); return; }
      const bias = startLatLng || L.latLng(43.6532, -79.3832);
      const url = new URL('https://photon.komoot.io/api/');
      url.searchParams.set('q', q);
      url.searchParams.set('limit', '8');
      url.searchParams.set('lat', String(bias.lat));
      url.searchParams.set('lon', String(bias.lng));
      url.searchParams.set('lang', 'en');

      try {
        const res = await fetch(url.toString(), { method: 'GET' });
        const data = await res.json();
        const feats = (data.features || []).map(f => {
          const name = featureName(f) || (f.properties && f.properties.osm_value) || 'Unnamed place';
          const coords = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
          const dist = haversine(bias, coords);
          return { name, coords, dist, raw: f };
        });

        feats.sort((a, b) => a.dist - b.dist);
        currentResults = feats; activeIndex = -1; renderResults(feats);
      } catch (e) {
        console.error(e);
        showToast('Search failed. Try again.');
        hideResults();
      }
    }

    function renderResults(items) {
      if (!items.length) { hideResults(); return; }
      resultsEl.innerHTML = items.map((it, i) => `
        <div class="result" data-index="${i}">
        <div class="pin"></div>
        <div>
            <div class="rmain">${escapeHtml(it.name)}</div>
            <div class="rsub">${escapeHtml((it.raw.properties && it.raw.properties.type) || 'POI')}</div>
        </div>
        <div class="rdist">${fmtDist(it.dist)}</div>
        </div>
    `).join('');
      resultsEl.style.display = 'block';
    }
    function hideResults() { resultsEl.style.display = 'none'; resultsEl.innerHTML = ''; currentResults = []; activeIndex = -1; }
    function escapeHtml(s) { return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }


    // Fetches a Wikimedia image by coordinates or name (no API key needed)
    async function fetchWikimediaImageByCoord(lat, lon, titleHint = "") {
      try {
        // Search near the coordinates (5000m radius)
        const url = `https://commons.wikimedia.org/w/api.php?action=query&prop=imageinfo&generator=geosearch&ggscoord=${lat}|${lon}&ggsradius=5000&ggslimit=1&iiprop=url&format=json&origin=*`;
        const res = await fetch(url);
        const data = await res.json();

        if (data?.query?.pages) {
          const page = Object.values(data.query.pages)[0];
          if (page?.imageinfo?.[0]?.url) return page.imageinfo[0].url;
        }

        // If no nearby photo, try name-based search
        if (titleHint) {
          const nameURL = `https://commons.wikimedia.org/w/api.php?action=query&titles=${encodeURIComponent(
            titleHint
          )}&prop=pageimages&pithumbsize=600&format=json&origin=*`;
          const res2 = await fetch(nameURL);
          const data2 = await res2.json();
          const page2 = Object.values(data2.query.pages)[0];
          if (page2?.thumbnail?.source) return page2.thumbnail.source;
        }
      } catch (e) {
        console.warn("No Wikimedia image found:", e);
      }
      return null;
    }


    function chooseIndex(i) {
      if (i < 0 || i >= currentResults.length) return;
      const item = currentResults[i];
      destinationEl.value = item.name;
      chosenPlace = item;
      highlightActive(i);
      hideResults();

      // Random Unsplash image for mock photo
      const randomPhoto = `https://source.unsplash.com/600x400/?${encodeURIComponent(item.name)}`;
      showPlaceCard(item.name, randomPhoto);
    }
    function highlightActive(i) {
      Array.from(resultsEl.children).forEach((el, idx) => { if (idx === i) el.classList.add('active'); else el.classList.remove('active'); });
    }
    function moveActive(delta) {
      if (!currentResults.length) return;
      activeIndex = ((activeIndex + delta) % currentResults.length + currentResults.length) % currentResults.length;
      highlightActive(activeIndex);
    }
    const debounceSearch = debounce(() => searchPlaces(destinationEl.value.trim()), 250);
    destinationEl.addEventListener('input', () => { chosenPlace = null; debounceSearch(); });
    destinationEl.addEventListener('keydown', (e) => {
      if (resultsEl.style.display !== 'block') return;
      if (e.key === 'ArrowDown') { e.preventDefault(); moveActive(1); }
      else if (e.key === 'ArrowUp') { e.preventDefault(); moveActive(-1); }
      else if (e.key === 'Enter') { if (activeIndex >= 0) { e.preventDefault(); chooseIndex(activeIndex); } else hideResults(); }
      else if (e.key === 'Escape') { hideResults(); }
    });
    resultsEl.addEventListener('mousedown', (e) => {
      const card = e.target.closest('.result'); if (!card) return;
      const i = Number(card.getAttribute('data-index')); chooseIndex(i);
    });
    document.addEventListener('click', (e) => { if (!e.target.closest('.searchwrap')) hideResults(); });

    /* --- Go: snap fake target to road, then route --- */
    document.getElementById('go').addEventListener('click', async () => {
      const text = destinationEl.value.trim();
      if (!text) return alert("Type a destination first!");
      // üî• Remove old routes and markers
      if (routing) { map.removeControl(routing); routing = null; }
      if (animatedLine) { map.removeLayer(animatedLine); animatedLine = null; }
      if (animatedShadow) { map.removeLayer(animatedShadow); animatedShadow = null; }
      map.eachLayer(layer => {
        if (layer instanceof L.Marker && layer !== liveDot && layer !== userMarker)
          map.removeLayer(layer);
      });
      const mode = getSelectedMode();

      if (isScenic()) {
        runScenic(mode).catch(() => showToast('Scenic misadventure failed ‚Äî try again üòÖ'));
        return; // don't do normal routing
      }

      // (keep your existing normal fake-target routing below)
      if (chosenPlace) {
        const d = fmtDist(haversine(startLatLng, chosenPlace.coords));
        showToast(`${mode.toUpperCase()} to ‚Äú${chosenPlace.name}‚Äù is ${d}. Calculating route...`);
      } else {
        showToast(`Searching ‚Äú${text}‚Äù then calculating route (${mode})...`);
      }

      try {
        const fakeSnapped = await pickFakeRoutableTarget(startLatLng, mode, 5, 6);
        routeToFakeDestination(fakeSnapped, mode);
      } catch (e) {
        showToast('Couldn‚Äôt find a nearby road for the fake target. Try again.');
      }
    });

    /* === Left Popup Info Card === */
    function showPlaceCard(name, imgSrc) {
      const card = document.getElementById('placeCard');
      const img = document.getElementById('placeCardImg');
      const title = document.getElementById('placeCardName');

      title.textContent = name;
      img.src = imgSrc || 'https://upload.wikimedia.org/wikipedia/commons/6/6f/No_image_available_500_x_500.svg';
      card.style.display = 'block';
    }

    function hidePlaceCard() {
      document.getElementById('placeCard').style.display = 'none';
    }

    document.getElementById('placeCardClose').addEventListener('click', hidePlaceCard);
    /* --- Snaking polyline helper (SVG dash trick) --- */
    let animatedLine = null, animatedShadow = null;

    function drawSnakingRoute(coords, opts = {}) {
      const {
        color = '#ff4da6',
        weight = 5,
        shadowColor = '#ffd1e8',
        shadowWeight = 8,
        durationMs = 1800,        // total animation time
        fit = true
      } = opts;

      // Clean previous animation
      if (animatedLine) { map.removeLayer(animatedLine); animatedLine = null; }
      if (animatedShadow) { map.removeLayer(animatedShadow); animatedShadow = null; }

      // Shadow path (optional, looks nice behind)
      animatedShadow = L.polyline(coords, {
        color: shadowColor, weight: shadowWeight, opacity: 0.6, pane: 'overlayPane'
      }).addTo(map);

      // Main path to animate
      animatedLine = L.polyline(coords, {
        color, weight, opacity: 0.95, lineCap: 'round', lineJoin: 'round', pane: 'overlayPane'
      }).addTo(map);

      // Ensure the SVG path exists before measuring
      requestAnimationFrame(() => {
        const path = animatedLine._path;               // underlying <path> element
        if (!path) return;

        const length = path.getTotalLength();
        // Set initial dash state (completely hidden)
        path.style.strokeDasharray = `${length}`;
        path.style.strokeDashoffset = `${length}`;
        // Trigger layout then animate to 0
        path.getBoundingClientRect(); // force reflow
        path.style.transition = `stroke-dashoffset ${durationMs}ms linear`;
        path.style.strokeDashoffset = '0';
      });

      if (fit) {
        const b = L.polyline(coords).getBounds();
        map.fitBounds(b, { padding: [40, 40] });
      }

      return animatedLine;
    }
    function isScenic() {
      const el = document.getElementById('scenicToggle');
      return !!(el && el.checked);
    }

  </script>
  <script>
    /* === Scenic helpers === */
    function antipode(ll) {
      // Opposite point on Earth
      const lat = -ll.lat;
      let lng = ll.lng + 180;
      if (lng > 180) lng -= 360;
      return L.latLng(lat, lng);
    }

    // Great-circle interpolation between two points (Vincenty-style unit vector slerp)
    function gcSample(a, b, steps = 200) {
      const œÜ1 = toRad(a.lat), Œª1 = toRad(a.lng);
      const œÜ2 = toRad(b.lat), Œª2 = toRad(b.lng);

      // convert to 3D unit vectors
      const v1 = [
        Math.cos(œÜ1) * Math.cos(Œª1),
        Math.cos(œÜ1) * Math.sin(Œª1),
        Math.sin(œÜ1)
      ];
      const v2 = [
        Math.cos(œÜ2) * Math.cos(Œª2),
        Math.cos(œÜ2) * Math.sin(Œª2),
        Math.sin(œÜ2)
      ];

      // angle between
      const dot = Math.max(-1, Math.min(1, v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]));
      const Œ© = Math.acos(dot);
      if (Œ© === 0) return [L.latLng(a.lat, a.lng), L.latLng(b.lat, b.lng)];

      const sinŒ© = Math.sin(Œ©);
      const pts = [];
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const s1 = Math.sin((1 - t) * Œ©) / sinŒ©;
        const s2 = Math.sin(t * Œ©) / sinŒ©;
        const x = s1 * v1[0] + s2 * v2[0];
        const y = s1 * v1[1] + s2 * v2[1];
        const z = s1 * v1[2] + s2 * v2[2];
        const œÜ = Math.atan2(z, Math.hypot(x, y));
        const Œª = Math.atan2(y, x);
        pts.push(L.latLng(toDeg(œÜ), toDeg(Œª)));
      }
      return pts;
    }

    // Sum length of a polyline in meters
    function pathLengthMeters(coords) {
      let sum = 0;
      for (let i = 1; i < coords.length; i++) {
        sum += haversine(coords[i - 1], coords[i]);
      }
      return sum;
    }
    // Put this near your helpers
    const LAND_PIVOTS = [
      { name: 'Iceland', lat: 64.9631, lng: -19.0208 },
      { name: 'Reykjav√≠k', lat: 64.1466, lng: -21.9426 },
      { name: 'Sahara', lat: 23.4162, lng: 25.6628 },
      { name: 'Cape Town', lat: -33.9249, lng: 18.4241 },
      { name: 'Perth', lat: -31.9505, lng: 115.8605 },
      { name: 'Ushuaia', lat: -54.8019, lng: -68.3030 },
      { name: 'Honolulu', lat: 21.3069, lng: -157.8583 },
      { name: 'Santiago', lat: -33.4489, lng: -70.6693 },
      { name: 'Tokyo', lat: 35.6762, lng: 139.6503 },
      { name: 'Madagascar', lat: -18.7669, lng: 46.8691 },
      { name: 'Patagonia', lat: -49.3315, lng: -72.8856 },
      { name: 'Mongolia', lat: 46.8625, lng: 103.8467 }
    ];

    // pick a far-away land pivot (>= 8000 km), jittered so it's not identical every time
    function pickScenicPivot(start) {
      const FAR_KM = 8000;
      const candidates = LAND_PIVOTS
        .map(p => ({ p, d: haversine(start, p) / 1000 }))
        .filter(x => x.d >= FAR_KM)
        .sort((a, b) => b.d - a.d)
        .slice(0, 6); // top few farthest options
      let chosen;
      if (candidates.length) {
        chosen = candidates[Math.floor(Math.random() * candidates.length)].p;
      } else {
        // fallback: a randomized ‚Äúquasi-antipode‚Äù that isn‚Äôt exactly ocean-locked
        const anti = antipode(start);
        const rot = (Math.random() * 120 - 60); // rotate ¬±60¬∞ in longitude
        chosen = { lat: anti.lat, lng: anti.lng + rot };
      }
      // jitter ~¬±2‚Äì4¬∞ so you don‚Äôt hit the exact same spot
      const jitterDeg = 2 + Math.random() * 2;
      const sign = () => (Math.random() < 0.5 ? -1 : 1);
      return L.latLng(
        chosen.lat + sign() * jitterDeg,
        chosen.lng + sign() * jitterDeg
      );
    }

    async function runScenic(mode) {
      if (!startLatLng) { showToast('Need your location first!'); return; }

      // End near you (still ‚Äúwrong‚Äù), to keep the joke
      let end = null;
      try {
        end = chosenPlace ? chosenPlace.coords : await pickFakeRoutableTarget(startLatLng, mode, 5, 6);
      } catch {
        end = makeRandomNearbyTarget(startLatLng, 4);
      }

      // Make a far-away detour near your antipode, nudged randomly so it isn‚Äôt literally exact
      const anti = antipode(startLatLng);
      const detour = pickScenicPivot(startLatLng);

      // Build great-circle legs with plenty of points for a smooth snake
      const leg1 = gcSample(startLatLng, detour, 280);
      const leg2 = gcSample(detour, end, 280);

      // Optional: sprinkle a tiny local ‚Äúarrival squiggle‚Äù so it feels map-like
      const arrival = [end];
      for (let i = 0; i < 6; i++) {
        const jitter = makeRandomNearbyTarget(end, 0.2); // ~200m wiggles
        arrival.push(jitter);
      }
      arrival.push(end);

      const coords = [...leg1, ...leg2, ...arrival];

      // Animate
      drawSnakingRoute(coords, {
        color: '#1a73e8',
        shadowColor: '#bcd9ff',
        durationMs: 12000, // long, satisfying snake
        fit: true
      });

      // Stats
      const distM = pathLengthMeters(coords);
      const emoji = { car: 'üöó', walk: 'üö∂', bus: 'üöå', train: 'üöÜ' }[mode] || 'üöó';

      // Absurd ETAs (just for fun)
      const avgKmH = (mode === 'walk') ? 5 : (mode === 'train') ? 80 : (mode === 'bus') ? 25 : 70;
      const etaMin = (distM / 1000) / avgKmH * 60;

      // Marker + popup
      L.marker(end, { title: 'Totally sensible scenic finish' }).addTo(map)
        .bindPopup(`Scenic route engaged üó∫Ô∏è<br>${emoji} <b>${fmtDist(distM)}</b> ‚Ä¢ ~<b>${fmtMins(etaMin)}</b><br><i>Hope you packed snacks.</i>`)
        .openPopup();

      showToast('Taking the long way around the planet‚Ä¶');
    }

  </script>

  <!-- Right-click context menu -->
  <div id="ctxmenu" class="ctxmenu"></div>

  <!-- Measure HUD -->
  <div id="measureHUD" class="measure-hud">Distance: 0 m</div>
</body>

</html>